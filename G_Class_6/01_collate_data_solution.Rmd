---
date: "2023-11-06"
title: "Class G, Mocap data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# to make things easy, we will use pacman. Please install it if you don't have it already
# with install.packages("pacman")

# packages to load
pacman::p_load("XML", "tidyverse", "fs", "assertthat", "stringi", "dtw")

# make sure we are in the G_Class_6 directory
wd <- getwd()
if (basename(wd) != "G_Class_6") {
  setwd("./G_Class_6")
}

# set the directory for the data
data_dir <- path_home() %>% 
  path("OneDrive - Aarhus universitet", "PercActMotionCapture", "labeled_data", "tsvs")

# set your study group
group_number <- 0


# The available conditions and their start and end frame indices
# to use the whole file, just set the value for the condition to c(NA, NA)
conditions <- list(
  jointlead = c(100, 10000),
  followlead = c(100, 10000),
  leadfollow = c(100, 10000),
  custom = c(100, 10000)
)



```

```{r helper_functions, include=FALSE}
# adapted from
# https://github.com/zeyus/QTM_Bela_Sonification/blob/main/scripts/step_01_import_raw_data.R

process_qtm_tsv <- function(
    data_file,
    condition_regex = "group[0-9]+_([^_\\.]+).*",
    null_value = "NA"
  ) {
  "This function processes a QTM TSV file and reads it into a dataframe.

  You will get both the trajectory data (dataframe) as well as metadata.

  Args:
    data_file (str): The path to the QTM TSV file.
    condition_regex (str): A regex to extract the condition from the file name.
    null_value (str): The value in the files that represents a missing measurement.

  Returns:
    A list with two elements:
      - data: The trajectory data as a dataframe.
      - metadata: A list with the metadata.
          The metadata contains the following elements:
            - condition: The condition of the data.
            - frequency: The frequency (Hz) of the data.
            - marker_count: The number of markers.
            - frame_count: The number of frames.
            - marker_names: The names of the markers.
  "

  message(paste("Processing", data_file))

  # get the condition
  cond <- stri_match_last_regex(data_file, condition_regex)[2]
  # make condition lowercase
  cond <- tolower(cond)
  message(paste("Condition:", cond))

  # read in the data
  dat <- readLines(data_file)

  # now get other relevant metadata
  # get frequency
  freq <- stri_match_first_regex(dat, "^FREQUENCY.*")
  freq <- freq[!is.na(freq)]

  # get marker count
  marker_count <- stri_extract_first_regex(dat, "^NO_OF_MARKERS.*")
  marker_count <- marker_count[!is.na(marker_count)]
  marker_count_value <- as.integer(stri_split_fixed(marker_count, "\t")[[1]][2])

  # get frame count
  frame_count <- stri_extract_first_regex(dat, "^NO_OF_FRAMES.*")
  frame_count <- frame_count[!is.na(frame_count)]
  frame_count_value <- as.integer(stri_split_fixed(frame_count, "\t")[[1]][2])

  # get marker names
  marker_names <- stri_extract_first_regex(dat, "^MARKER_NAMES.*")
  marker_names <- marker_names[!is.na(marker_names)]
  marker_names_values <- stri_split_fixed(
    marker_names,
    "\t"
  )[[1]][1:marker_count_value + 1]
  message("File information:")
  message(paste(freq, "Hz", "frequency"))
  message(paste(marker_count_value, "markers"))
  message(paste(frame_count_value, "frames"))

  # now just keep the tracking information
  dat <- stri_extract_first_regex(dat, "^[0-9]+\t.*")
  dat <- dat[!is.na(dat)]

  # now ensure the number of frames is correct
  # this is the number of lines in the data
  assertthat::assert_that(
    length(dat) == frame_count_value,
    msg = paste(
      "Number of frames is not correct, found:",
      length(dat),
      "expected:",
      frame_count_value)
  )

  # ensure the number of markers is correct
  # this is 3 columns per marker, plus index and time
  num_found_markers <- length(stri_split_fixed(dat[[1]], "\t")[[1]])
  assertthat::assert_that(
    num_found_markers == marker_count_value * 3 + 2,
    msg = paste(
      "Number of markers is not correct, found:",
      num_found_markers,
      "expected:",
      marker_count_value * 3 + 2)
  )

  message(paste("File has", length(dat), "frames"))
  message(paste("File has", marker_count_value, "markers"))

  message("Creating data frame...")

  col_names <- c(
    "index",
    "elapsed_time",
    paste0(
      rep(marker_names_values, each = 3),
      c("_x", "_y", "_z")
    )
  )


  # now we need to create a data frame
  
  # split each line by tab
  dat <- stri_split_fixed(dat, "\t", simplify = TRUE)
  # set the column names
  colnames(dat) <- col_names
  # and then convert to a data frame
  dat <- as_tibble(dat)
  # now we need to replace the null values with NA
  dat[dat == null_value] <- NA
  # and convert to numeric
  dat <- mutate_all(dat, as.numeric)

  metadata <- list(
    condition = cond,
    frequency = freq,
    marker_count = marker_count,
    frame_count = frame_count,
    marker_names = marker_names
  )

  # return the data and metadata
  return(list(data = dat, metadata = metadata))

}



gap_fill_linear <- function(x) {
  "This function does a linear gap fill for a vector.

  Only columns with at least 2 non-NA values will be gap filled.

  Args:
    x (vector): The vector to gap fill.

  Returns:
    The gap filled vector.
  "
  # get the indices of the NA values
  na_indices <- which(is.na(x))
  # get the indices of the non-NA values
  non_na_indices <- which(!is.na(x))

  if (length(na_indices) == 0) {
    # if there are no NA values, just return the vector
    return(x)
  }

  if (length(non_na_indices) < 2) {
    # if there are less than 2 non-NA values, we can't do a linear interpolation
    return(x)
  }
  # get the values of the non-NA indices
  non_na_values <- x[non_na_indices]
  # get the values of the NA indices
  na_values <- x[na_indices]
  # now we can do a linear interpolation
  na_values <- approx(
    x = non_na_indices,
    y = non_na_values,
    xout = na_indices,
    method = "linear"
  )$y
  # now we can replace the NA values with the interpolated values
  x[na_indices] <- na_values
  # and return the vector
  return(x)
}

```

```{r 'Load Trajectory Labels'}
# load the labels from the XML file

# load the XML file
xmlfile <- xmlParse("./resources/PerAct23_LabelList.xml")

# get the labels, which are in the following format:
# <QTM_Label_List_Ver_1.00>
#     <Trajectories>
#         <Trajectory>
#             <Name>A_head_top</Name>
#             <Color R="0" G="147" B="0"/>
#         </Trajectory>
#     </Trajectories>
# </QTM_Label_List_Ver_1.00>

# get the trajectory names
traj_names <- xpathSApply(xmlfile, "//Trajectory/Name", xmlValue)

# get the trajectory colors
traj_colors <- xpathSApply(xmlfile, "//Trajectory/Color", xmlAttrs)

# convert the colors to hex
traj_colors <- rgb(
  as.numeric(traj_colors[1,]),
  as.numeric(traj_colors[2,]),
  as.numeric(traj_colors[3,]),
  alpha = 255,
  maxColorValue = 255
)


# combine the names and colors into a data frame
traj_labels <- data.frame(
  traj_names,
  traj_colors,
  stringsAsFactors = FALSE
)

rm(xmlfile, traj_names, traj_colors)

```

```{r 'Load Trajectory Data'}

# load the trajectory data, we want all TSVs with the group number in the name

# get the files
traj_files <- fs::dir_ls(data_dir, regexp = paste0("group", group_number, "_.*\\.tsv$"))

# load the data
traj_data <- lapply(traj_files, process_qtm_tsv)


# now we need to combine the data into a single data frame

# first we need to add the condition and group to each data frame
traj_data <- lapply(traj_data, function(x) {
  x$data$condition <- x$metadata$condition
  x$data$group <- paste0("group", group_number)
  return(x)
})

# now we can combine the data
traj_data <- do.call(bind_rows, lapply(traj_data, `[[`, "data"))

# make the condition and group factors
traj_data$condition <- factor(traj_data$condition)
traj_data$group <- factor(traj_data$group)

# take a look at the data
head(traj_data)

# let's also make sure that all of the marker names are the same
# we can do this by getting the unique marker names
marker_names <- unique(traj_data %>% select(contains("_x")) %>% names() %>% stri_replace_last_regex("_x", ""))

# now we can check that all of the marker names are the same
assertthat::assert_that(
  all(marker_names == traj_labels$traj_names),
  msg = "Not all marker names are the same"
)
```

```{r 'Crop trajectory data'}

# We want to crop the data for each condition
# let's get all the recorded conditions
recorded_conditions <- unique(traj_data$condition)
for (cond in recorded_conditions) {
  # get the start and end frame for the condition
  start_frame <- conditions[[cond]][1]
  if (is.na(start_frame)) start_frame <- 1
  end_frame <- conditions[[cond]][2]
  if (is.na(end_frame)) end_frame <- max(traj_data[traj_data$condition == cond, "index"])
  # crop the data
  traj_data <- traj_data %>% 
    filter(condition == cond & index >= start_frame & index <= end_frame | condition != cond)
}

# select min and max indices by condition
traj_data %>% 
  group_by(condition) %>% 
  summarise(min_index = min(index), max_index = max(index))


```

```{r 'Check for large jumps in trajectory data'}
# we want to check for large jumps in the data
# this indicates potential label errors

# we will do this by calculating the distance between each marker for each time point
# of course, by condition

# calculate euclidean distance between each marker
# we have the marker names in traj_labels

# first we need to get the marker names
marker_names <- traj_labels$traj_names

# now we can calculate the euclidean distance between each marker (using x, y, z)
# we will do this by condition
marker_distances <- traj_data %>% 
  group_by(condition) %>% 
  mutate_at(
    vars(contains("_x") | contains("_y") | contains("_z")),
    ~ .x - lag(.x)
  )

# now we can calculate the euclidean distance per maker
marker_distances_euclidean <- marker_distances %>% 
  pivot_longer(
    cols = contains("_x") | contains("_y") | contains("_z"),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "value"
  ) %>%
  mutate(
    marker = stri_replace_last_regex(marker, "_x|_y|_z", "")
  ) %>%
  group_by(index, condition, marker) %>%
  summarise_at(
    vars(value),
    ~ sqrt(sum(.^2, na.rm = TRUE))
  )

# now we can plot the series for each marker, and see if anything stands out
marker_distances_euclidean %>% 
  ggplot(aes(x = index, y = value, color = marker)) +
  geom_line() +
  theme_minimal() +
  facet_wrap(~condition) +
  labs(
    x = "Index",
    y = "Euclidean distance",
    title = "Euclidean distance between markers"
  )


```

```{r 'Get informatnion about NAs'}	

# get NAs counts
# by condition, marker
nas_cond_marker <- traj_data %>%
  select(condition | contains("_X")) %>%
  group_by(condition) %>%
  summarise_at(
    vars(contains("_X")),
    ~ sum(is.na(.)) / length(.) * 100
  ) %>%
  pivot_longer(
    cols = contains("_X"),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "value"
  ) %>%
  mutate(
    marker = stri_replace_last_regex(marker, "_X", "")
  )


# plot to check if it is acceptable
nas_cond_marker %>% 
  ggplot(aes(x = marker, y = value, fill=marker)) +
  geom_col(
    show.legend = FALSE
  ) +
  coord_flip() +
  theme_minimal() +
  facet_wrap(~condition) +
  labs(
    x = "Marker",
    y = "Number of NA values",
    title = "Number of NA values by marker"
  )


# Now we can get the longest sequence of NAs for each marker
longest_na_seq <- traj_data %>% 
  select(condition | contains("_x")) %>%
  group_by(condition) %>%
  summarise_at(
    vars(contains("_x")),
    ~ max(rle(is.na(.))$lengths)
  ) %>%
  pivot_longer(
    cols = contains("_x"),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "lengths"
  ) %>%
  mutate(
    marker = stri_replace_last_regex(marker, "_x", "")
  )

longest_na_seq <- longest_na_seq %>%
  unlist() %>%
  as_tibble() %>% 
  mutate(marker = seq_markers) %>% 
  arrange(desc(value))

# plot to check if it is acceptable
longest_na_seq %>% 
  ggplot(aes(x = marker, y = lengths, fill=marker)) +
  geom_col(
    show.legend = FALSE
  ) +
  coord_flip() +
  theme_minimal() +
  facet_wrap(~condition) +
  labs(
    x = "Marker",
    y = "Longest NA sequence",
    title = "Longest NA sequence by marker"
  )
```

```{r 'Choose markers of interest'}
# we want to choose the markers of interest
# we will choose the following markers:
# - {A,B}_head_top
# - {A,B}_hand_right
# you may of course choose different markers, or if those ones were
# particularly bad, you should select others

# get the markers of interest
markers_of_interest <- c(
  "A_hand_left",
  "B_hand_left",
  "A_hand_right",
  "B_hand_right"
)

# now we can select the markers of interest
selected_traj_data <- traj_data %>% 
  select(
    contains(markers_of_interest) | 
      contains("elapsed_time") | 
      contains("condition") | 
      contains("group") |
      contains("index")
  )

```

```{r 'Gap fill trajectory data'}
# we are only going to do a linear gap fill, it's not elegant, but it works
# we will do this for each marker x, y, and z
sel_idx = 1
# plot a single marker's x, y, and z values before and after gap filling
selected_traj_data %>% 
  select(contains(markers_of_interest[sel_idx]) | elapsed_time | condition) %>% 
  group_by(condition) %>%
  pivot_longer(
    cols = contains(markers_of_interest[sel_idx]),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "value"
  ) %>%
  mutate(
    marker = factor(
      marker,
      levels = c(
        paste0(markers_of_interest[sel_idx], "_x"),
        paste0(markers_of_interest[sel_idx], "_y"),
        paste0(markers_of_interest[sel_idx], "_z")
      )
    )
  ) %>%
  ggplot(aes(x = elapsed_time, y = value, color = marker)) +
  geom_line() +
  theme_minimal() +
  facet_wrap(~condition) +
  labs(
    x = "Elapsed time",
    y = "Marker position",
    title = "Marker position before gap filling"
  )

# now we can apply our linear gap fill function to each column, by condition
selected_traj_data <- selected_traj_data %>% 
  group_by(condition) %>% 
  mutate_at(
    vars(contains("_x")),
    gap_fill_linear
  ) %>% 
  mutate_at(
    vars(contains("_y")),
    gap_fill_linear
  ) %>% 
  mutate_at(
    vars(contains("_z")),
    gap_fill_linear
  ) %>%
  ungroup()

# plot a single marker's x, y, and z after gap filling
selected_traj_data %>% 
  select(contains(markers_of_interest[sel_idx]) | elapsed_time | condition) %>% 
  group_by(condition) %>%
  pivot_longer(
    cols = contains(markers_of_interest[sel_idx]),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "value"
  ) %>%
  mutate(
    marker = factor(
      marker,
      levels = c(
        paste0(markers_of_interest[sel_idx], "_x"),
        paste0(markers_of_interest[sel_idx], "_y"),
        paste0(markers_of_interest[sel_idx], "_z")
      )
    )
  ) %>%
  ggplot(aes(x = elapsed_time, y = value, color = marker)) +
  geom_line() +
  theme_minimal() +
  facet_wrap(~condition) +
  labs(
    x = "Elapsed time",
    y = "Marker position",
    title = "Marker position after gap filling"
  )

```


```{r 'Cross correlation analysis'}
# we want to do a cross correlation analysis
# we will do this by condition and marker using our markers_of_interest

# first we need to get the data into a format that is suitable for cross correlation
# we will do this by condition and marker
# we will also do this for each axis (x, y, z),
# using each axis seperately will simplify the analysis
# otherwise we need to use another summary statistic

# we know there are always two subjects, and the
# marker labels start with the subject (A or B)
# we want to cross correlate between the same marker for
# subject A and subject B

traj_xcor_data <- selected_traj_data %>% 
  group_by(condition) %>% 
  pivot_longer(
    cols = contains("_x") | contains("_y") | contains("_z"),
    cols_vary = "slowest",
    names_to = "marker",
    values_to = "value"
  ) %>%
  mutate(
    subject = stri_extract_last_regex(marker, "^[AB]"),
    marker = stri_replace_last_regex(marker, "^[AB]_", "")
  )


# now we can do the cross correlation analysis using ccf
# we want to compare e.g. A_head_top_x with B_head_top_x
# for each condition

# define an empty list to store the results
xcor_results <- list()
for (marker in markers_of_interest) {
  # get the data for the marker
  marker_data <- traj_xcor_data %>% 
    filter(marker == marker)
  # get the unique conditions
  conds <- unique(marker_data$condition)
  # now we can do the cross correlation analysis
  for (cond in conds) {
    # get the data for the condition
    cond_data <- marker_data %>% 
      filter(condition == cond)
    # now we can do the cross correlation analysis
    # we will do this for each axis
    for (axis in c("_x", "_y", "_z")) {
      # get the data for the axis
      axis_data <- cond_data %>% 
        filter(str_detect(marker, axis))
      # now we can do the cross correlation analysis
      # we will do this for each subject
      results <- ccf(
        x = axis_data[axis_data$subject == "A", "value"],
        y = axis_data[axis_data$subject == "B", "value"],
        na.action = na.omit,
        plot = FALSE
      )
      # make a tibble with the results
      results <- tibble(
        lagv = results$lag,
        acfv = results$acf,
        marker = marker,
        condition = cond
      )
      xcor_results[[length(xcor_results) + 1]] <- results
    }
  }
}

# let's put all the acf results into a single tibble
xcor_results <- do.call(bind_rows, xcor_results)


# now we can plot the results for each lag point
xcor_results %>%
  ggplot(aes(x = lagv, y = acfv, color = marker)) +
  geom_point() +
  theme_minimal() +
  facet_wrap(c(~condition, ~marker)) +
  labs(
    x = "Lag",
    y = "Autocorrelation",
    title = "Autocorrelation by lag"
  )

# now let's plot the max acf for each condition and marker
xcor_results %>%
  group_by(condition, marker) %>%
  summarise_at(
    vars(acfv),
    ~ max(.)
  ) %>%
  ggplot(aes(x = condition, y = acfv, fill = condition)) +
  geom_col(
    show.legend = FALSE
  ) +
  theme_minimal() +
  facet_wrap(~marker) +
  labs(
    x = "Condition",
    y = "Max autocorrelation",
    title = "Max autocorrelation by condition"
  )

```

```{r 'Dynamic time warping for a single marker'}
# we want to do dynamic time warping for a single marker
# we will do this for each condition
# To do this, it's just a matter of getting the time series for each subject and condition

# pick a single marker to do the analysis on
sel_marker <- "hand_right_z"
conds <- unique(selected_traj_data$condition)
# define the window size (in samples)
# this is how far ahead and behind we can look for a match
# given a sample rate of 300 Hz, 1 second is 300 samples
window_size <- 300
results <- list()
for (cond in conds) {
  # get the data for the condition
  col_x <- paste0("A_", sel_marker)
  col_y <- paste0("B_", sel_marker)
  cond_data <- selected_traj_data %>% 
    filter(condition == cond)
  # now we can do the dynamic time warping for the marker between subjects
  message(paste("Doing dynamic time warping for condition:", cond, "Marker:", sel_marker))
  message("This may take a while...")
  result <- dtw(
    x = cond_data[, col_x],
    y = cond_data[, col_y],
    window.type = "sakoechiba",
    window.size = window_size,
    keep = TRUE
  )
  results[length(results) + 1] <- result$normalizedDistance
  # plot the results
  message("Plotting results...")
  message("Generating alignment plot...")
  plot(result, type = "alignment")
  message("Generating twoway plot...")
  plot(result, type = "twoway")
  message("Generating threeway plot...")
  plot(result, type = "threeway")
  message("Generating density plot, burning computer...")
  plot(result, type = "density")
}

# print the resulting normalized distances
results

```

